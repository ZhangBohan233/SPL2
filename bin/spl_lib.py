import sys
import time as time_lib
import os
from bin import spl_memory as mem


LINE_FILE = 0, "spl_lib"


def replace_bool_none(string: str):
    """
    Returns a str with 'None', 'True', and 'False' replaced with 'null', 'true', and 'false'.

    This function also removes quotes generated by spl String object.

    :param string: the str object to be replaced
    :return: a str with 'None', 'True', and 'False' replaced with 'null', 'true', and 'false'
    """
    in_single = False
    in_double = False
    lst = []
    i = 0
    while i < len(string):
        ch = string[i]
        if in_single:
            if ch == "'":
                in_single = False
                i += 1
                continue
        elif in_double:
            if ch == '"':
                in_double = False
                i += 1
                continue
        else:
            if ch == "'":
                in_single = True
                i += 1
                continue
            elif ch == '"':
                in_double = True
                i += 1
                continue
        if not in_single and not in_double:
            if i <= len(string) - 4:
                if string[i:i + 4] == "True":
                    lst.append("true")
                    i += 4
                    continue
                elif string[i:i + 4] == "None":
                    lst.append("null")
                    i += 4
                    continue
            if i <= len(string) - 5:
                if string[i:i + 5] == "False":
                    lst.append("false")
                    i += 5
                    continue
        lst.append(ch)
        i += 1
    return "".join(lst)


def compile_time_warning(msg: str):
    sys.stderr.write(msg + "\n")
    sys.stderr.flush()


def concatenate_path(path: str, directory: str) -> str:
    if os.path.isabs(path):
        return path
    else:
        return directory + os.sep + path


def get_string_literal(lit) -> str:
    if lit is None:
        return "null"
    elif isinstance(lit, bool):
        return "true" if lit else "false"
    elif isinstance(lit, CharArray):
        return lit.literal
    else:
        return str(lit)


def get_string_repr(o) -> str:
    if o is None:
        return "null"
    elif isinstance(o, bool):
        return "true" if o else "false"
    elif isinstance(o, int) or isinstance(o, float):
        return str(o)
    elif isinstance(o, CharArray):
        return "'" + o.__repr__() + "'"
    else:
        return repr(o)


# Native functions with no dependency


class SplObject:
    """
    An superset of spl objects.

    There are two types of SplObjects: NativeType and Class

    # ----- Attributes -----
    #     id: the identifier of this object, is guaranteed to be unique
    """
    id: int

    def __init__(self):
        self.id = mem.MEMORY.allocate(self)


class NativeType(SplObject):
    def __init__(self):
        SplObject.__init__(self)

    @classmethod
    def type_name__(cls) -> str:
        raise NotImplementedError

    @classmethod
    def doc__(cls) -> str:
        """
        :return: the doc string of this type
        """
        doc = ["NativeObject ", cls.type_name__(), " ", cls.__doc__, "\n"]
        for x in dir(cls):
            if len(x) < 2 or x[-2:] != "__":
                attr = getattr(cls, x)
                if callable(attr):
                    doc.append("    method ")
                    doc.append(x)
                    doc.append("(")
                    params = attr.__code__.co_varnames
                    for p in params:
                        if p != "self":
                            doc.append(p)
                            doc.append(", ")
                    if doc[-1] == ", ":
                        doc.pop()
                    doc.append("):")
                    doc.append("\n")
                    attr_doc = attr.__doc__
                    if attr_doc:
                        doc.append(attr_doc)
                        doc.append("\n")
        return "".join([str(x) for x in doc])


class Iterable:
    def __init__(self):
        pass

    def __iter__(self):
        raise NotImplementedError


class CharArray(NativeType, Iterable):
    """
    An object of a string literal.
    """

    def __init__(self, lit):
        NativeType.__init__(self)

        self.literal: str = get_string_literal(lit)

    def __contains__(self, item):
        return item in self.literal

    def __iter__(self):
        return (c for c in self.literal)

    def __str__(self):
        return self.literal

    def __repr__(self):
        return self.__str__()

    def __eq__(self, other):
        return isinstance(other, CharArray) and self.literal == other.literal

    def __hash__(self):
        return hash(self.literal)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __add__(self, other):
        if isinstance(other, CharArray):
            return CharArray(self.literal + other.literal)
        else:
            raise TypeException("Cannot add <CharArray> with <{}>".format(type(other).__name__))

    def __getitem__(self, index):
        return CharArray(self.literal[index])

    def __int__(self):
        return int(self.literal)

    def __float__(self):
        return float(self.literal)

    def is_alpha(self):
        return self.literal.isalpha()

    def length(self):
        """
        Returns the length of this string.

        :return: the length of this string
        """
        return len(self.literal)

    @classmethod
    def type_name__(cls):
        return "CharArray"

    def substring(self, from_, to):
        length = self.length()
        if from_ < 0 or to > length:
            raise IndexOutOfRangeException("Substring index out of range")
        return CharArray(self.literal[from_: to])


class PyInputStream(NativeType):
    def __init__(self, stream):
        NativeType.__init__(self)

        self.stream = stream

    @classmethod
    def type_name__(cls) -> str:
        return "PyInputStream"

    def read(self):
        return self.stream.read()

    def readline(self):
        return self.stream.readline()

    def close(self):
        self.stream.close()


class PyOutputStream(NativeType):
    def __init__(self, stream):
        NativeType.__init__(self)

        self.stream = stream

    @classmethod
    def type_name__(cls) -> str:
        return "PyOutputStream"

    def write(self, obj):
        self.stream.write(str(obj))

    def flush(self):
        self.stream.flush()

    def close(self):
        self.stream.close()


class System(NativeType, mem.EnvironmentCarrier):
    """
    A class consists of system calls

    ----- Attributes -----
        argv: command line arguments
        cwd: the working directory
        encoding: the encoding mode
        stdout: system standard output stream, ClassInstance extends OutputStream
        stderr: system standard error output stream, ClassInstance extends OutputStream
        stdin: system standard input stream, ClassInstance extends InputStream
    """

    argv = None  # Array
    cwd: CharArray
    encoding: str
    native_in = None
    native_out = None
    native_err = None
    stdout = None  # ClassInstance <NativeOutputStream>
    stderr = None  # ClassInstance <NativeOutputStream>
    stdin = None  # ClassInstance <NativeInputStream>

    def __init__(self, argv_, directory: CharArray, enc: str, in_out_err):
        NativeType.__init__(self)

        self.native_in = PyInputStream(in_out_err[0])
        self.native_out = PyOutputStream(in_out_err[1])
        self.native_err = PyOutputStream(in_out_err[2])
        self.cwd = directory
        self.argv = argv_
        self.encoding = enc

    def get_envs(self):
        lst = []
        if isinstance(self.stdin, mem.EnvironmentCarrier):
            lst += self.stdin.get_envs()
        if isinstance(self.stdout, mem.EnvironmentCarrier):
            lst += self.stdout.get_envs()
        if isinstance(self.stderr, mem.EnvironmentCarrier):
            lst += self.stderr.get_envs()
        return lst

    def set_in(self, in_):
        self.stdin = in_

    def set_out(self, out):
        self.stdout = out

    def set_err(self, err):
        self.stderr = err

    @staticmethod
    def time():
        """
        Returns the current system time, in millisecond.

        :return: the current system time, in millisecond
        """
        return int(time_lib.time() * 1000)

    @staticmethod
    def sleep(milli):
        """
        Pause the current thread for a period of time, in millisecond.

        :param milli: the time to pause, in millisecond
        """
        time_lib.sleep(milli / 1000)

    @classmethod
    def type_name__(cls):
        return "System"


# Exceptions

class InterpretException(Exception):
    def __init__(self, msg=""):
        Exception.__init__(self, msg)


class SplException(InterpretException):
    def __init__(self, msg=""):
        InterpretException.__init__(self, msg)


class NameException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class TypeException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class IndexOutOfRangeException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class PyIOException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class AbstractMethodException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class UnauthorizedException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class IllegalOperationException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class ArgumentException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class ArithmeticException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class AttributeException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class StringFormatException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


class MemoryException(SplException):
    def __init__(self, msg=""):
        SplException.__init__(self, msg)


def to_int(v):
    return int(v)


def to_float(v):
    return float(v)


def to_boolean(v):
    return True if v else False


# etc


class InvalidArgument:
    def __init__(self):
        pass

    def __str__(self):
        return "INVALID"


class UnpackArgument:
    def __init__(self):
        pass

    def __str__(self):
        return "UNPACK"


class KwUnpackArgument:
    def __init__(self):
        pass

    def __str__(self):
        return "KW_UNPACK"
